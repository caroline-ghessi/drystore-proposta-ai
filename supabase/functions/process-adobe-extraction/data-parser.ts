export interface ExtractedData {
  client?: string;
  items: Array<{
    description: string;
    quantity: number;
    unit: string;
    unitPrice: number;
    total: number;
  }>;
  subtotal: number;
  total: number;
  paymentTerms?: string;
  delivery?: string;
  vendor?: string;
}

export class DataParser {
  static parseAdobeData(adobeData: any): ExtractedData {
    console.log('üîç Starting enhanced Brazilian PDF parsing...');
    
    const result: ExtractedData = {
      items: [],
      subtotal: 0,
      total: 0
    };

    try {
      // Extract text to identify client and other information
      const elements = adobeData.elements || [];
      let allText = '';
      
      elements.forEach((element: any) => {
        if (element.Text) {
          allText += element.Text + ' ';
        }
      });

      console.log('üìÑ Extracted text length:', allText.length);
      console.log('üî§ First 500 chars:', allText.substring(0, 500));

      // MELHORADA: Identifica√ß√£o de cliente brasileiro
      result.client = this.extractBrazilianClient(allText);

      // Extract tables with enhanced Brazilian logic
      const tables = adobeData.tables || [];
      
      tables.forEach((table: any, tableIndex: number) => {
        console.log(`üîç Processing table ${tableIndex + 1}:`, table);
        this.processBrazilianTableComprehensive(table, result);
      });

      // Calculate totals
      result.subtotal = result.items.reduce((sum, item) => sum + item.total, 0);
      result.total = result.subtotal;

      // Extract additional Brazilian information
      this.extractBrazilianPaymentTerms(allText, result);
      this.extractBrazilianDeliveryInfo(allText, result);
      this.extractBrazilianVendorInfo(allText, result);

      console.log(`‚úÖ Enhanced parsing completed: ${result.items.length} items, total: R$ ${result.total.toFixed(2)}`);

      // NOVO: Valida√ß√£o contra total esperado
      this.validateTotalDiscrepancy(result);

    } catch (error) {
      console.error('‚ùå Error in enhanced parsing:', error);
    }

    return result;
  }

  // MELHORADA: Processamento comprehensivo de tabelas brasileiras
  private static processBrazilianTableComprehensive(table: any, result: ExtractedData): void {
    const rows = table.rows || [];
    
    if (rows.length < 2) {
      console.log('‚ö†Ô∏è Table too small, skipping...');
      return;
    }

    console.log(`üìã Table has ${rows.length} total rows to analyze`);

    // INTELIGENTE: Detectar cabe√ßalho da tabela
    let headerRowIndex = this.findBrazilianTableHeader(rows);
    console.log(`üìã Header detected at row: ${headerRowIndex}`);

    // INTELIGENTE: Mapear colunas baseado no cabe√ßalho
    const columnMapping = this.mapBrazilianTableColumns(rows[headerRowIndex]);
    console.log('üóÇÔ∏è Column mapping:', columnMapping);

    // NOVO: Processar TODAS as linhas, n√£o parar prematuramente
    for (let i = headerRowIndex + 1; i < rows.length; i++) {
      const row = rows[i];
      const cells = row.cells || [];
      
      console.log(`üîç Analyzing row ${i}:`, cells.map(c => c.content || '').join(' | '));
      
      // FLEX√çVEL: Aceitar linhas com pelo menos 2 c√©lulas v√°lidas
      if (cells.length < 2) {
        console.log(`‚è≠Ô∏è Row ${i} skipped - insufficient cells (${cells.length})`);
        continue;
      }

      const item = this.extractBrazilianItemFromRowRobust(cells, columnMapping, i);
      
      if (item && this.isValidBrazilianItem(item)) {
        result.items.push(item);
        console.log(`‚úÖ Added item ${result.items.length}: ${item.description} - Qty: ${item.quantity} - Price: R$ ${item.unitPrice} - Total: R$ ${item.total}`);
      } else {
        console.log(`‚ùå Row ${i} rejected - invalid item:`, item);
      }
    }

    console.log(`üìä Final table processing result: ${result.items.length} items extracted`);
  }

  // NOVA: Extra√ß√£o robusta de item da linha
  private static extractBrazilianItemFromRowRobust(cells: any[], mapping: any, rowIndex: number): any {
    const description = mapping.description >= 0 ? 
      (cells[mapping.description]?.content || '').trim() : 
      (cells[0]?.content || '').trim(); // Fallback para primeira coluna
    
    const quantityText = mapping.quantity >= 0 ? 
      (cells[mapping.quantity]?.content || '0').trim() : 
      (cells[1]?.content || '0').trim(); // Fallback para segunda coluna
    
    const unitPriceText = mapping.unitPrice >= 0 ? 
      (cells[mapping.unitPrice]?.content || '0').trim() : 
      (cells[2]?.content || '0').trim(); // Fallback para terceira coluna
    
    const totalText = mapping.total >= 0 ? 
      (cells[mapping.total]?.content || '0').trim() : 
      (cells[3]?.content || '0').trim(); // Fallback para quarta coluna

    console.log(`üßÆ Row ${rowIndex} extraction: desc="${description}", qty="${quantityText}", price="${unitPriceText}", total="${totalText}"`);

    // MELHORADA: Limpeza de valores monet√°rios brasileiros
    const quantity = this.parseBrazilianNumber(quantityText);
    const unitPrice = this.parseBrazilianCurrency(unitPriceText);
    let total = totalText ? this.parseBrazilianCurrency(totalText) : 0;
    
    // INTELIGENTE: Se n√£o temos total, calcular
    if (total === 0 && quantity > 0 && unitPrice > 0) {
      total = quantity * unitPrice;
      console.log(`üßÆ Calculated total for row ${rowIndex}: ${quantity} √ó ${unitPrice} = ${total}`);
    }

    // NOVA: Extrair unidade se poss√≠vel
    const unit = this.extractBrazilianUnit(quantityText) || 'UN';

    const item = {
      description: description,
      quantity,
      unit,
      unitPrice,
      total
    };

    console.log(`üì¶ Processed item from row ${rowIndex}:`, item);
    return item;
  }

  // NOVA: Valida√ß√£o mais flex√≠vel de itens brasileiros
  private static isValidBrazilianItem(item: any): boolean {
    const hasDescription = item.description && item.description.length > 2;
    const hasQuantity = item.quantity > 0;
    const hasValue = item.unitPrice > 0 || item.total > 0;
    
    // FLEX√çVEL: Item √© v√°lido se tem descri√ß√£o E (quantidade OU valor)
    const isValid = hasDescription && (hasQuantity || hasValue);
    
    console.log(`‚úÖ Item validation: desc=${hasDescription}, qty=${hasQuantity}, value=${hasValue} ‚Üí valid=${isValid}`);
    
    // Rejeitar apenas se for claramente um cabe√ßalho ou linha vazia
    const isHeader = /^(descri√ß√£o|c√≥digo|item|produto|quantidade|qtd|valor|pre√ßo|total|subtotal)$/i.test(item.description);
    
    return isValid && !isHeader;
  }

  // NOVA: Valida√ß√£o de discrep√¢ncia total
  private static validateTotalDiscrepancy(result: ExtractedData): void {
    const expectedTotals = [17188.80, 14047.20]; // Valores conhecidos do PDF
    const calculatedTotal = result.total;
    
    console.log(`üí∞ Total validation: calculated=${calculatedTotal.toFixed(2)}`);
    
    for (const expected of expectedTotals) {
      const discrepancy = Math.abs(calculatedTotal - expected);
      const percentDiff = (discrepancy / expected) * 100;
      
      console.log(`üìä Against expected ${expected}: diff=${discrepancy.toFixed(2)} (${percentDiff.toFixed(1)}%)`);
      
      if (discrepancy > 1000) {
        console.log(`‚ö†Ô∏è LARGE DISCREPANCY DETECTED: Missing items worth R$ ${discrepancy.toFixed(2)}`);
      }
    }
  }

  // NOVA: Identifica√ß√£o espec√≠fica de clientes brasileiros
  private static extractBrazilianClient(text: string): string | undefined {
    console.log('üîç Extracting Brazilian client...');
    
    const clientPatterns = [
      // Padr√µes espec√≠ficos para propostas brasileiras
      /(?:cliente|raz√£o social|empresa):\s*([A-Z√Å√ä√î√á√É√ï\s&\-\.]{3,50})/i,
      /(?:para|destinat√°rio):\s*([A-Z√Å√ä√î√á√É√ï\s&\-\.]{3,50})/i,
      /(?:cnpj)[\s:]*[\d\.\-\/]+\s*([A-Z√Å√ä√î√á√É√ï\s&\-\.]{3,50})/i,
      // Padr√£o espec√≠fico para o PDF Pedro Bartelle
      /(?:pedro\s+bartelle|bartelle)/i,
      // Nomes pr√≥prios brasileiros comuns
      /(?:^|\s)([A-Z√Å√ä√î√á√É√ï]{3,}\s+[A-Z√Å√ä√î√á√É√ï\s&\-\.]{3,30})(?:\s|$)/,
    ];

    for (const pattern of clientPatterns) {
      const match = text.match(pattern);
      if (match && match[1]) {
        const clientName = match[1].trim();
        if (clientName.length > 3 && clientName.length < 50) {
          console.log('‚úÖ Client identified:', clientName);
          return clientName;
        }
      }
    }

    // Fallback: procurar por nomes em mai√∫scula
    const uppercasePattern = /\b([A-Z√Å√ä√î√á√É√ï]{3,}\s+[A-Z√Å√ä√î√á√É√ï\s&]{3,30})\b/g;
    const matches = [...text.matchAll(uppercasePattern)];
    
    for (const match of matches) {
      const candidate = match[1].trim();
      if (this.isValidBrazilianName(candidate)) {
        console.log('‚úÖ Client identified (uppercase):', candidate);
        return candidate;
      }
    }

    console.log('‚ö†Ô∏è No client identified');
    return undefined;
  }

  // NOVA: Valida√ß√£o de nomes brasileiros
  private static isValidBrazilianName(name: string): boolean {
    // Excluir palavras comuns que n√£o s√£o nomes
    const excludeWords = [
      'DESCRI√á√ÉO', 'QUANTIDADE', 'VALOR', 'TOTAL', 'UNIT√ÅRIO',
      'PRODUTO', 'SERVI√áO', 'ITEM', 'C√ìDIGO', 'PRE√áO',
      'PROPOSTA', 'OR√áAMENTO', 'PEDIDO', 'NOTA', 'FISCAL'
    ];
    
    return !excludeWords.some(word => name.includes(word)) && 
           name.length >= 6 && 
           name.length <= 40 &&
           /^[A-Z√Å√ä√î√á√É√ï\s&\-\.]+$/.test(name);
  }

  // NOVA: Detectar cabe√ßalho de tabela brasileira
  private static findBrazilianTableHeader(rows: any[]): number {
    const headerKeywords = [
      'descri√ß√£o', 'description', 'produto', 'item',
      'quantidade', 'qtd', 'qty', 'quant',
      'valor', 'pre√ßo', 'price', 'unit√°rio', 'unit',
      'total', 'subtotal'
    ];

    for (let i = 0; i < Math.min(3, rows.length); i++) {
      const row = rows[i];
      const cells = row.cells || [];
      const headerText = cells.map((cell: any) => (cell.content || '').toLowerCase()).join(' ');
      
      const keywordCount = headerKeywords.filter(keyword => 
        headerText.includes(keyword)
      ).length;
      
      if (keywordCount >= 2) {
        return i;
      }
    }

    return 0; // Default to first row
  }

  // NOVA: Mapear colunas da tabela brasileira
  private static mapBrazilianTableColumns(headerRow: any): any {
    const cells = headerRow.cells || [];
    const mapping: any = {
      description: -1,
      quantity: -1,
      unitPrice: -1,
      total: -1,
      unit: -1
    };

    cells.forEach((cell: any, index: number) => {
      const content = (cell.content || '').toLowerCase();
      
      // Mapear descri√ß√£o
      if (content.includes('descri√ß√£o') || content.includes('produto') || content.includes('item')) {
        mapping.description = index;
      }
      // Mapear quantidade
      else if (content.includes('quantidade') || content.includes('qtd') || content.includes('qty')) {
        mapping.quantity = index;
      }
      // Mapear pre√ßo unit√°rio
      else if (content.includes('unit√°rio') || content.includes('unit') || content.includes('pre√ßo')) {
        mapping.unitPrice = index;
      }
      // Mapear total
      else if (content.includes('total') && !content.includes('subtotal')) {
        mapping.total = index;
      }
    });

    // Fallback inteligente baseado na posi√ß√£o
    if (mapping.description === -1 && cells.length >= 1) mapping.description = 0;
    if (mapping.quantity === -1 && cells.length >= 2) mapping.quantity = 1;
    if (mapping.unitPrice === -1 && cells.length >= 3) mapping.unitPrice = 2;
    if (mapping.total === -1 && cells.length >= 4) mapping.total = 3;

    return mapping;
  }

  // NOVA: Parse de n√∫meros brasileiros (v√≠rgula como decimal)
  private static parseBrazilianNumber(text: string): number {
    // Remove tudo exceto d√≠gitos, v√≠rgulas e pontos
    let cleaned = text.replace(/[^\d.,]/g, '');
    
    // Se tem v√≠rgula e ponto, v√≠rgula √© decimal
    if (cleaned.includes(',') && cleaned.includes('.')) {
      // Ex: 1.234,56 -> 1234.56
      cleaned = cleaned.replace(/\./g, '').replace(',', '.');
    } else if (cleaned.includes(',')) {
      // Ex: 1234,56 -> 1234.56
      cleaned = cleaned.replace(',', '.');
    }
    
    return parseFloat(cleaned) || 0;
  }

  // NOVA: Parse de moeda brasileira
  private static parseBrazilianCurrency(text: string): number {
    // Remove s√≠mbolos de moeda (R$, reais, etc.)
    let cleaned = text.replace(/[R$\s]/g, '');
    cleaned = cleaned.replace(/reais?/gi, '');
    
    return this.parseBrazilianNumber(cleaned);
  }

  // NOVA: Extrair unidade brasileira
  private static extractBrazilianUnit(text: string): string | undefined {
    const unitPatterns = [
      /(\b(?:PC|P√á|UN|M|CM|MM|KG|G|L|ML)\b)/i,
      /(\b(?:PE√áA|UNIDADE|METRO|CENT√çMETRO|QUILOGRAMA|GRAMA|LITRO)\b)/i
    ];

    for (const pattern of unitPatterns) {
      const match = text.match(pattern);
      if (match) {
        return match[1].toUpperCase();
      }
    }

    return undefined;
  }

  // MELHORADA: Termos de pagamento brasileiros
  private static extractBrazilianPaymentTerms(text: string, result: ExtractedData): void {
    const paymentPatterns = [
      /(?:pagamento|forma de pagamento|condi√ß√µes):\s*([^.\n\r]{5,50})/i,
      /(?:prazo|vencimento):\s*([^.\n\r]{5,50})/i,
      /(?:boleto|cart√£o|pix|transfer√™ncia|√† vista)[\s\w\/]*([^.\n\r]{5,50})/i
    ];

    for (const pattern of paymentPatterns) {
      const match = text.match(pattern);
      if (match) {
        result.paymentTerms = match[1].trim();
        break;
      }
    }
  }

  // MELHORADA: Informa√ß√µes de entrega brasileiras
  private static extractBrazilianDeliveryInfo(text: string, result: ExtractedData): void {
    const deliveryPatterns = [
      /(?:entrega|prazo de entrega|delivery):\s*([^.\n\r]{5,50})/i,
      /(?:data de entrega|entregar em):\s*([^.\n\r]{5,50})/i,
      /(?:\d{1,2}\/\d{1,2}\/\d{2,4})/g
    ];

    for (const pattern of deliveryPatterns) {
      const match = text.match(pattern);
      if (match) {
        result.delivery = match[1] ? match[1].trim() : match[0];
        break;
      }
    }
  }

  // MELHORADA: Informa√ß√µes de vendedor brasileiras
  private static extractBrazilianVendorInfo(text: string, result: ExtractedData): void {
    const vendorPatterns = [
      /(?:vendedor|representante|atendente|consultor):\s*([A-Z√Å√ä√î√á√É√ï\s]{3,30})/i,
      /(?:respons√°vel|contato):\s*([A-Z√Å√ä√î√á√É√ï\s]{3,30})/i
    ];

    for (const pattern of vendorPatterns) {
      const match = text.match(pattern);
      if (match && match[1].trim().length > 3) {
        result.vendor = match[1].trim();
        break;
      }
    }
  }
}
